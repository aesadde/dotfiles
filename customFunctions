# vim: ft=sh

function extract()      # Handy Extract Program
{
    if [ -f $1 ] ; then
        case $1 in
            *.tar.bz2)   tar xvjf $1     ;;
    *.tar.gz)    tar xvzf $1     ;;
    *.bz2)       bunzip2 $1      ;;
    *.rar)       unrar x $1      ;;
    *.gz)        gunzip $1       ;;
    *.tar)       tar xvf $1      ;;
    *.tbz2)      tar xvjf $1     ;;
    *.tgz)       tar xvzf $1     ;;
    *.zip)       unzip $1        ;;
    *.Z)         uncompress $1   ;;
    *.7z)        7z x $1         ;;
    *)           echo "'$1' cannot be extracted via >extract<" ;;
    esac
    else
        echo "'$1' is not a valid file!"
            fi
}

# Creates an archive (*.tar.gz) from given directory.
function maketar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }

# Create a ZIP archive of a file or folder.
function makezip() { zip -r "${1%%/}.zip" "$1" ; }

# Make your directories and files access rights sane.
function sanitize() { chmod -R u=rwX,g=rX,o= "$@" ;}

# Function calls cht.sh (awesome cheatsheets!)
function cheat() {
      curl cht.sh/$1
  }

# Install (one or multiple) selected application(s)
# using "brew search" as source input
# mnemonic [B]rew [I]nstall [P]lugin
bip() {
  local inst=$(brew search | fzf -m)

  if [[ $inst ]]; then
    for prog in $(echo $inst);
    do; brew install $prog; done;
  fi
}

# Update (one or multiple) selected application(s)
# mnemonic [B]rew [U]pdate [P]lugin
bup() {
  local upd=$(brew leaves | fzf -m)

  if [[ $upd ]]; then
    for prog in $(echo $upd);
    do; brew upgrade $prog; done;

  fi
}

# Delete (one or multiple) selected application(s)
# mnemonic [B]rew [C]lean [P]lugin (e.g. uninstall)
bcp() {
  local uninst=$(brew leaves | fzf -m)

  if [[ $uninst ]]; then
    for prog in $(echo $uninst);
    do; brew uninstall $prog; done;
  fi
}

# ==[ Kube stuff ]==
kproxy() {
# Forward the ports to connect to the akorda proxy
kubectl port-forward svc/proxy-svc 8080:8080
}


kc() {
  kubectl config get-contexts | tail -n +2 | fzf | cut -c 2- | awk '{print $1}' | xargs kubectl config use-context
}

# ==[ MISC ]==

conda_activate() {
  local selected_env
  selected_env=$(ls ~/miniconda3/envs | fzf)

  if [ -n "$selected_env" ]; then
    source activate $selected_env
  fi
}



topcmd() {
  history | awk '{a[$2]++}END{for(i in a){print a[i] " " i}}' | sort -rn | head
}


# From https://www.usenix.org/sites/default/files/conference/protected-files/lisa19_maheshwari.pdf
mcd() { mkdir -p $1; cd $1 }
cdl() { cd $1; ls}
backup() { cp "$1"{,.bak};} #test first
gfind() { find / -iname $@ 2>/dev/null }
lfind() { find . -iname $@ 2>/dev/null }
rtfm() { help $@ || man $@ || open "http://www.google.com/search?q=$@"; }


## ==[ 1 Password ]==
### ref: https://austincloud.guru/2018/11/27/1password-cli-tricks/
opon() {
  if [[ -z $OP_SESSION_my ]]; then
    eval $(op signin my)
  fi
}

opoff() {
  op signout
  unset OP_SESSION_my
}

getpwd() {
  opon
  op get item "$1" |jq -r '.details.fields[] |select(.designation=="password").value'
}

## ==[ Jira ]==
function create_branch() {
  local jq_template query username password branch_name

  jq_template='"'\ '\(.key). \(.fields.summary)'\ '\t'\ 'Reporter: \(.fields.reporter.displayName)\n'\ '\(.fields.description)'\ '"'
  query='project=ACM AND assignee=currentUser() AND sprint in openSprints()'
  username="alberto@akorda.com"
  password=$(getpwd jira-api)

  branch_name=$(
    curl \
      --data-urlencode "jql=$query" \
      --get \
      --user "$username:$password" \
      --silent \
      --compressed \
      'https://akorda.atlassian.net/rest/api/3/search' |
    jq -r '.issues[] | "\(.key)\t\(.fields.issuetype.name)\t\(.fields.summary)"' |
    fzf |
    awk '{printf "%s/%s", tolower($2), tolower($1)}' |
    sed -e 's/story/feat/' -e 's/bug/fix/' -e 's/task/feat/'
  )

  if [ -n "$branch_name" ]; then
    git checkout -b "$branch_name"
  fi
}
